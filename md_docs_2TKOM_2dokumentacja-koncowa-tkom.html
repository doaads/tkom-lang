<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TKOM Programming Language and Interpreter: Techniki Kompilacji - Dokumentacja Końcowa</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TKOM Programming Language and Interpreter
   </div>
   <div id="projectbrief">An implementation of a programming language for ZPR and TKOM projects</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2TKOM_2dokumentacja-koncowa-tkom.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Techniki Kompilacji - Dokumentacja Końcowa</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a><em>Bartosz Nowak, 325201</em></p>
<h1><a class="anchor" id="autotoc_md1"></a>
1. Opis Języka</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
1.1 Typy danych i Operatory</h2>
<h3><a class="anchor" id="autotoc_md3"></a>
1.1.1 Typy Danych</h3>
<p>Zaimplementowane zostały następujące typy danych:</p>
<ol type="1">
<li>Integer:<ul>
<li><code>int</code></li>
</ul>
</li>
<li>Float<ul>
<li><code>flt</code></li>
</ul>
</li>
<li><code>string</code></li>
<li><code>bool</code><ul>
<li><code>true</code></li>
<li><code>false</code></li>
</ul>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md4"></a>
1.1.2 Operatory</h3>
<p>Zdefiniowana została następująca kolejność operatorów:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">priorytet   </th><th class="markdownTableHeadNone"><b>operatory</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><b>0.</b>   </td><td class="markdownTableBodyNone">dekorator: <code>@</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><b>1.</b>   </td><td class="markdownTableBodyNone">bind-front: <code>-&gt;&gt;</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><b>2.</b>   </td><td class="markdownTableBodyNone">wywołanie, ciąg wywołań: <code>-&gt;</code>, nawiasy    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><b>3.</b>   </td><td class="markdownTableBodyNone">unarne: <code>!</code>, <code>-</code>, <code>+</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><b>4.</b>   </td><td class="markdownTableBodyNone">mnożenie, dzielenie: <code>*</code>, <code>/</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><b>5.</b>   </td><td class="markdownTableBodyNone">dodawanie, odejmowanie: <code>+</code>, <code>-</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><b>6.</b>   </td><td class="markdownTableBodyNone">porównywanie: <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>!=</code>, <code>==</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><b>7.</b>   </td><td class="markdownTableBodyNone">logiczne AND, OR: <code>&amp;&amp;</code>, <code>\|\|</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><b>8.</b>   </td><td class="markdownTableBodyNone">przypisanie: <code>=&gt;</code>   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md5"></a>
1.1.3 Konwersja typów</h3>
<ul>
<li><code>int</code> -&gt; <code>flt</code><ul>
<li>Konwersja typu całkowitego na zmiennoprzecinkowy. (<code>12 -&gt; 12.0</code>)</li>
</ul>
</li>
<li><code>flt</code> -&gt; <code>int</code><ul>
<li>Zaokrąglenie w dół. (<code>12.5 -&gt; 12</code>)</li>
</ul>
</li>
<li><code>int</code> -&gt; <code>string</code>, <code>flt</code> -&gt; <code>string</code><ul>
<li>Zamiana liczby na postać tekstową. (<code>123 -&gt; "123"</code>)</li>
</ul>
</li>
<li><code>int</code> -&gt; <code>bool</code>, <code>flt</code> -&gt; <code>bool</code><ul>
<li>Jeśli wartość jest różna od 0 - zamiana na true (<code>1 -&gt; true, -1 -&gt; true</code>)</li>
<li>Jeśli wartość jest równa 0 - zamiana na false (<code>0 -&gt; false, 0.0 -&gt; false</code>)</li>
</ul>
</li>
<li><code>bool</code> -&gt; <code>int</code>, <code>bool</code> -&gt; <code>flt</code><ul>
<li><code>true -&gt; 1, false -&gt; 0</code></li>
</ul>
</li>
<li><code>string</code> -&gt; <code>bool</code><ul>
<li>Zamienia na true jeśli string nie jest pusty, w przeciwnym wypadku false</li>
</ul>
</li>
<li><code>bool</code> -&gt; <code>string</code><ul>
<li><code>true -&gt; "true", false -&gt; "false"</code></li>
</ul>
</li>
<li><code>string</code> -&gt; <code>int</code>, <code>string</code> -&gt; <code>flt</code><ul>
<li>Konwersja do typów liczbowych, jeżeli takowa jest możliwa (za pomocą <code>std::stoi</code>, <code>std::stod</code>)</li>
</ul>
</li>
</ul>
<p>Tabela konwersji typów dla operacji arytmetycznych:</p>
<p>L\R Oznacza pozycję względem operatora</p>
<ul>
<li>Operator <code>+</code></li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">L\R (+)   </th><th class="markdownTableHeadCenter">int   </th><th class="markdownTableHeadCenter">flt   </th><th class="markdownTableHeadCenter">string   </th><th class="markdownTableHeadCenter">bool    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">int   </td><td class="markdownTableBodyCenter">int   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">int    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">flt    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">string    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">bool   </td><td class="markdownTableBodyCenter">int   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">bool   </td></tr>
</table>
<ul>
<li>Operator <code>-</code></li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">L\R (-)   </th><th class="markdownTableHeadCenter">int   </th><th class="markdownTableHeadCenter">flt   </th><th class="markdownTableHeadCenter">string   </th><th class="markdownTableHeadCenter">bool    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">int   </td><td class="markdownTableBodyCenter">int   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">int    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">flt    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">bool   </td><td class="markdownTableBodyCenter">int   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">int   </td></tr>
</table>
<ul>
<li>Operator <code>*</code></li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">L\R (*)   </th><th class="markdownTableHeadCenter">int   </th><th class="markdownTableHeadCenter">flt   </th><th class="markdownTableHeadCenter">string   </th><th class="markdownTableHeadCenter">bool    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">int   </td><td class="markdownTableBodyCenter">int   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">int    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">flt    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">string    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">bool   </td><td class="markdownTableBodyCenter">int   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">bool   </td></tr>
</table>
<ul>
<li>Operator <code>/</code></li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">L\R (/)   </th><th class="markdownTableHeadCenter">int   </th><th class="markdownTableHeadCenter">flt   </th><th class="markdownTableHeadCenter">string   </th><th class="markdownTableHeadCenter">bool    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">int   </td><td class="markdownTableBodyCenter">int   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">int    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">flt    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">bool   </td><td class="markdownTableBodyCenter">int   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">int   </td></tr>
</table>
<ul>
<li>Dla operatorów równości (<code>==</code>, <code>!=</code>) oraz logicznego AND i OR zawsze następuje konwersja obu stron do typu <code>bool</code></li>
<li>Dla operatorów porównania: (<code>&lt;, &gt;, &lt;=, &gt;=</code>) oba czynniki są rzutowane na następujący typ:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"></th><th class="markdownTableHeadCenter">int   </th><th class="markdownTableHeadCenter">flt   </th><th class="markdownTableHeadCenter">string   </th><th class="markdownTableHeadCenter">bool    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">int   </td><td class="markdownTableBodyCenter">int   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">int    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">flt    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">string   </td><td class="markdownTableBodyCenter">-    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">bool   </td><td class="markdownTableBodyCenter">int   </td><td class="markdownTableBodyCenter">flt   </td><td class="markdownTableBodyCenter">-   </td><td class="markdownTableBodyCenter">int   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md6"></a>
1.2 Definiowanie zmiennych</h2>
<p>Definicja zmiennych odbywa się przy użyciu operatora <code>=&gt;</code> w następujący sposób:</p>
<div class="fragment"><div class="line">5 =&gt; <span class="keywordtype">int</span> <a class="code hl_function" href="arithmetics_8h.html#a9390d8a36fc2d7229efffb33781e79c0">b</a>;  <span class="comment">// odpowiednik int b = 5</span></div>
<div class="ttc" id="aarithmetics_8h_html_a9390d8a36fc2d7229efffb33781e79c0"><div class="ttname"><a href="arithmetics_8h.html#a9390d8a36fc2d7229efffb33781e79c0">are_of_arithmetic_rank</a></div><div class="ttdeci">constexpr auto are_of_arithmetic_rank() -&gt; bool</div><div class="ttdoc">function for checking if types are of arithmetic rank for 2-argument functions</div><div class="ttdef"><b>Definition</b> arithmetics.h:25</div></div>
</div><!-- fragment --><p>Po lewej stronie operatora mogą być obecne bardziej złożone wyrażenia</p>
<div class="fragment"><div class="line">5 + 10 * 2 =&gt; <span class="keywordtype">int</span> <a class="code hl_function" href="arithmetics_8h.html#a9390d8a36fc2d7229efffb33781e79c0">c</a>;</div>
</div><!-- fragment --><p>Język jest <b>słabo typowany</b>, zatem w następującej sytuacji:</p>
<div class="fragment"><div class="line">5.5 * 2 + 2 =&gt; <span class="keywordtype">int</span> <a class="code hl_function" href="arithmetics_8h.html#a9390d8a36fc2d7229efffb33781e79c0">a</a>;</div>
</div><!-- fragment --><p>Zostaną wykonane następujące operacje:</p><ol type="1">
<li>Zrzutowanie literału 2 -&gt; 2.0</li>
<li>Wykonanie operacji mnożenia</li>
<li>Zrzutowanie literału 2 -&gt; 2.0</li>
<li>Wykonanie dodawania</li>
</ol>
<p>Operatory <code>-</code> oraz <code>/</code> nie mogą działać z typem danych <code>string</code> (po żadnej ze stron, patrz tabelka w punkcie 1.1.3)</p>
<h3><a class="anchor" id="autotoc_md7"></a>
1.2.1 Czas życia zmiennych</h3>
<p>Czas życia zmiennych określony jest przez blok kodu, w którym zostały zdefiniowane i jest ograniczony za pomocą znaków <code>{}</code>.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
1.2.2 Przesłanianie zmiennych</h3>
<p>Przesłanianie zmiennych nie jest możliwe, próba zdefiniowania zmiennej o nazwie, która istnieje już w danej funkcji zostanie zakończona wyjątkiem:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code hl_function" href="lexer__main_8cpp.html#a808f40e2e9d6eb5463165c031dfa3eb1">main</a> {</div>
<div class="line">    5 =&gt; <span class="keywordtype">int</span> <a class="code hl_function" href="arithmetics_8h.html#a9390d8a36fc2d7229efffb33781e79c0">a</a>;</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="arithmetics_8h.html#a9390d8a36fc2d7229efffb33781e79c0">a</a> &gt; 0) {</div>
<div class="line">        10 =&gt; mut <span class="keywordtype">int</span> <a class="code hl_function" href="arithmetics_8h.html#a9390d8a36fc2d7229efffb33781e79c0">a</a>; <span class="comment">// niemożliwe, wystąpi błąd</span></div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_function" href="arithmetics_8h.html#a9390d8a36fc2d7229efffb33781e79c0">ret</a> 0;</div>
<div class="line">}</div>
<div class="ttc" id="alexer__main_8cpp_html_a808f40e2e9d6eb5463165c031dfa3eb1"><div class="ttname"><a href="lexer__main_8cpp.html#a808f40e2e9d6eb5463165c031dfa3eb1">main</a></div><div class="ttdeci">auto main(int argc, char **argv) -&gt; int</div><div class="ttdef"><b>Definition</b> lexer_main.cpp:10</div></div>
</div><!-- fragment --><p> sh Error: Exception thrown at 4:9 - <a class="el" href="structVariable.html" title="the variable definition">Variable</a> a is already defined in this frame 3 | if (a &gt; 0) { </p><blockquote class="doxtable">
<p>&zwj;4 | 10 =&gt; mut int a; // niemożliwe, wystąpi błąd ^ Exception thrown at 4:9 - <a class="el" href="structVariable.html" title="the variable definition">Variable</a> a is already defined in this frame 5 | } </p>
</blockquote>
<div class="fragment"><div class="line">#### 1.2.3 Widoczność zmiennych</div>
<div class="line"> </div>
<div class="line">Zmienne widoczne są w blokach, w których zostały zdefiniowane oraz w blokach podrzędnych.</div>
<div class="line"> </div>
<div class="line">### 1.3 Mutowalność</div>
<div class="line"> </div>
<div class="line">Zmienne w języku są domyślnie **niemutowalne**, w celu zdefiniowania mutowalnej zmiennej, konieczne będzie dodanie słowa kluczowego `mut` przed definicją typu.</div>
</div><!-- fragment --><p> c 5 =&gt; mut int a; </p><div class="fragment"><div class="line">wartość zmiennej mutowalnej możemy zmienić za pomocą operatora przypisania.</div>
</div><!-- fragment --><p> c 10 =&gt; a; </p><div class="fragment"><div class="line">### 1.4. Funkcje</div>
<div class="line">#### 1.4.1 Operator -&gt;</div>
<div class="line"> </div>
<div class="line">Operator *wołania funkcji* jest operatorem używanym w celu wywoływania funkcji. Ma on postać `-&gt;`.</div>
<div class="line"> </div>
<div class="line">Zmienne przekazywane są do funkcji przez **referencję**, zatem wyrażenie:</div>
</div><!-- fragment --><p> c (5) -&gt; increment =&gt; int a; </p><div class="fragment"><div class="line">utworzy tymczasową zmienną niemutowalną z literału 5, a następnie przekaże ją jako referencję do funkcji increment.</div>
<div class="line"> </div>
<div class="line">#### 1.4.2 Argumenty funkcji</div>
<div class="line"> </div>
<div class="line">Argumenty wywołania funkcji muszą znaleźć się z **lewej** strony operatora przekazania i **muszą** być zamknięte w nawias.</div>
</div><!-- fragment --><p> c (5) -&gt; increment =&gt; int a; // a = 6 (5, 6) -&gt; add =&gt; int b; // b = 11 () -&gt; no_argument_function =&gt; int c; </p><div class="fragment"><div class="line">#### 1.4.3 Funkcje jako argument</div>
<div class="line"> </div>
<div class="line">Funkcje mogą zostać przekazywane jako argumenty innych funkcji. W celu dokonania takiego przekazania należy użyć nazwy funkcji.</div>
</div><!-- fragment --><p> (5, increment) -&gt; apply_function =&gt; int a; </p><div class="fragment"><div class="line">#### 1.4.4 Typy zmiennych funkcji</div>
<div class="line"> </div>
<div class="line">Typ funkcji-zmiennych zapisywany jest w formie: `[&lt;ret_type&gt;::&lt;args&gt;]`</div>
</div><!-- fragment --><p> increment =&gt; [int::int] increment_function; </p><div class="fragment"><div class="line">#### 1.4.5 Definicja funkcji</div>
<div class="line"> </div>
<div class="line">Funkcje definiowane są przy użyciu operatora `::`, z którego lewej strony powinna znaleźć się nazwa funkcji poprzedzona typem danych zwracanych przez funkcję. Z prawej strony operatora powinny się znaleźć argumenty wywołania.</div>
</div><!-- fragment --><p> c mut int add :: int a, int b { a + b -&gt; ret; } </p><div class="fragment"><div class="line">Operator `::` powinien znaleźć się w definicji funkcji **jedynie** gdy definiujemy funkcję posiadającą argumenty, w innym przypadku należy tego unikać</div>
</div><!-- fragment --><p> cpp int main { ... } </p><div class="fragment"><div class="line">Słowo kluczowe `ret` odpowiada za zwrot z funkcji, operator przekazania przekazuje mu wartość, którą zwróci funkcja.</div>
<div class="line"> </div>
<div class="line">#### 1.4.6 Przekazywanie przez referencję</div>
<div class="line"> </div>
<div class="line">Zmienne przekazywane są do funkcji poprzez **referencję**, co oznacza, że następująca funkcja:</div>
</div><!-- fragment --><p> c void increment :: mut int a { a + 1 =&gt; a; ret; } </p><div class="fragment"><div class="line">Nie zwróci żadnej wartości, ale w przypadku wywołania jej za pomocą:</div>
</div><!-- fragment --><p> c 5 =&gt; mut int foo; (foo) -&gt; increment; (foo) -&gt; stdout; </p><div class="fragment"><div class="line">Zostanie wyświetlona wartość 6, zmienna `foo` zostanie zmodyfikowana wewnątrz funkcji.</div>
<div class="line">Ze względu na przekazywanie przez referencję. Do funkcji oczekujących mutowalnych argumentów, możemy przekazać również literały, ale musimy wtedy liczyć się z tym, że utracimy część wyniku w momencie wyjścia z funkcji. (Czas życia tych zmiennych zakończy się w momencie wyjścia z funkcji)</div>
<div class="line"> </div>
<div class="line">Z kolei w przypadku próby przekazania referencji do zmiennej niemutowalnej, zostanie rzucony wyjątek</div>
</div><!-- fragment --><p> cpp Error: Exception thrown at 3:9 - <a class="el" href="classType.html" title="Abstract class representing a Type.">Type</a> mismatch 2 | 10 =&gt; int a; </p><blockquote class="doxtable">
<p>&zwj;3 | (a)-&gt;increment; ^ Exception thrown at 3:9 - <a class="el" href="classType.html" title="Abstract class representing a Type.">Type</a> mismatch 4 | ret a; </p>
</blockquote>
<div class="fragment"><div class="line">#### 1.4.7 Przeciążanie funkcji</div>
<div class="line"> </div>
<div class="line">Przeciążanie funkcji nie jest dozwolone, próba zdefiniowania wielu funkcji o tej samej nazwie zakończy się błędem</div>
<div class="line"> </div>
<div class="line">### 1.5 If</div>
<div class="line"> </div>
<div class="line">If-statement definiowany jest następująco:</div>
</div><!-- fragment --><p> c if (a == b) { ret (5); } elif (a == c) { ret (6); } else { ret (1); } </p><div class="fragment"><div class="line">Operatory `==, &gt;=, &lt;=, !=, &gt;, &lt;` używane są do porównywania, warunki mogą być łączone za pomocą operatorów `&amp;&amp;` (AND) oraz `||` (OR).</div>
<div class="line"> </div>
<div class="line">#### 1.4.8 Wywoływanie w miejscu</div>
<div class="line"> </div>
<div class="line">Możliwe jest wywołanie funkcji w miejscu, taka funkcja będzie miała postać ciągu wywołań, przykładowy program dokonujący takiego wywołania znajduje się poniżej:</div>
<div class="line"> </div>
<div class="line">Parser rozpatruje ciąg wywołań funkcji początkowo rozwijając nazwę funkcji</div>
</div><!-- fragment --><p> cpp int main { (((5) -&gt; (0) -&gt; add_something) + "\n") -&gt; stdout; // powyższy kod oznacza: // zaaplikuj <code>0</code> do <code>add_something</code>, otrzymując funkcję // zaaplikuj <code>5</code> do otrzymanej funkcji // dodaj <code>"\n"</code> do wyniku // wywołaj jako argument funkcji <code>stdout</code></p>
<p>ret 0; }</p>
<p>[int::int] add_something :: int a { // funkcja zwraca funkcję some_func ret some_func; }</p>
<p>int some_func :: int a { // funkcja zwraca zadany argument ret a; } </p><div class="fragment"><div class="line">Powyższy kod wypisze na ekran cyfrę `5`.</div>
<div class="line"> </div>
<div class="line">### 1.6 Pętle</div>
<div class="line"> </div>
<div class="line">Język oferuje dwie konstrukcje pętli - `for` oraz `while`</div>
<div class="line"> </div>
<div class="line">#### 1.6.1 For</div>
<div class="line">Konstrukcja pętli `for` prezentuje się nastepująco:</div>
</div><!-- fragment --><p> c for (&lt;mutable variable&gt;; &lt;condition&gt;) { ... } -&gt; &lt;update expression&gt;; </p><div class="fragment"><div class="line">w praktyce mamy zatem:</div>
</div><!-- fragment --><p> c for (0 =&gt; mut int a; a &lt; 10) { ... } -&gt; increment; </p><div class="fragment"><div class="line">Konieczne jest podanie zmiennej, warunku działania pętli oraz funkcji wywoływanej po każdej iteracji</div>
<div class="line"> </div>
<div class="line">#### 1.6.2 While</div>
<div class="line"> </div>
<div class="line">Konstrukcja pętli `while` prezentuje się następująco:</div>
</div><!-- fragment --><p> c while (&lt;condition&gt;) { ... }</p>
<p>while (a &lt; 10) { ... } </p><div class="fragment"><div class="line">W pętli `while` mogą zostać użyte zmienne niemutowalne (ale może to spowodować powstanie nieskończonej pętli)</div>
</div><!-- fragment --><p> c 10 =&gt; mut int a; 12 =&gt; int b; while (a &lt; b) { (a) -&gt; increment; }</p>
<p>while (b) { ... } // effectively a while (true) loop </p><div class="fragment"><div class="line">### 1.8 Operacje I/O</div>
<div class="line"> </div>
<div class="line">Funkcja wbudowana `stdout` pozwala na wypisanie ciągu znaków na wyjście standardowe.</div>
</div><!-- fragment --><p> c ("wynik to" + 5) -&gt; stdout; </p><div class="fragment"></div><!-- fragment --><p> wynik to 5 </p><div class="fragment"><div class="line">Z kolei funkcja `stdin` pozwala na wczytanie ciągu znaków z wejścia standardowego przyjmując na wejście ciąg znaków.</div>
</div><!-- fragment --><p> c ("Podaj liczbe:") -&gt; stdin =&gt; string a; </p><div class="fragment"><div class="line">### 1.9 Funkcje wyższego rzędu - dekoratory</div>
<div class="line"> </div>
<div class="line">Dekoratory &quot;opakowują&quot; funkcje w inne funkcje.</div>
</div><!-- fragment --><p> c int main { ret () -&gt; add @ my_decorator; }</p>
<p>int my_decorator :: [int::int] other_function { ("hello from decorator before function! the value is: ") -&gt; stdout; (5) -&gt; other_function =&gt; int a; (a + "\n") -&gt; stdout; ("hello from decorator after function!\n") -&gt; stdout; ret a; }</p>
<p>int add::int some_value { ret some_value + 2; } </p><div class="fragment"><div class="line">Powyższy kod zwróci wynik</div>
</div><!-- fragment --><p> hello from decorator before function! the value is: 7 hello from decorator after function! </p><div class="fragment"><div class="line">Funkcje dekorujące **muszą** przyjmować funkcję o danej sygnaturze jako swój pierwszy argument.</div>
<div class="line"> </div>
<div class="line">Funkcje mogą być dekorowane w następujący sposób:</div>
</div><!-- fragment --><p> c my_function @ my_decorator =&gt; [int::int] decorated_function; </p><div class="fragment"></div><!-- fragment --><p> c (5) -&gt; decorated_function; </p><div class="fragment"><div class="line">Możliwa jest również jednorazowa dekoracja funkcji:</div>
</div><!-- fragment --><p> c (5) -&gt; add @ log =&gt; int a; </p><div class="fragment"><div class="line">Ze względu na priorytet operatorów, funkcja zostanie najpierw udekorowana, a następnie wywołana z wartością 5.</div>
<div class="line">Jako, że operator przypisania rozpatrywany jest na sam koniec, wartość przypisana do zmiennej `a` będzie wartością zwróconą przez udekorowaną funkcję.</div>
<div class="line"> </div>
<div class="line">### 1.10 Funkcje wyższego rzędu - bind front</div>
<div class="line"> </div>
<div class="line">Dla funkcji N argumentowej możliwe jest przypisanie stałych wartości dla n pierwszych argumentów za pomocą mechanizmu bind front.</div>
<div class="line">Przyjmijmy, że mamy funkcję `add` przyjmującą 2 argumenty i zwracającą ich sumę.</div>
</div><!-- fragment --><p> c int add :: int a, int b { ret a + b; } </p><div class="fragment"><div class="line">Możemy użyć operatora `-&gt;&gt;`, aby przypisać zmienne do pierwszych n argumentów funkcji</div>
</div><!-- fragment --><p> c (5) -&gt;&gt; add =&gt; [int::int] add5; </p><div class="fragment"><div class="line">Możemy do tego również użyć zmiennych mutowalnych</div>
<div class="line">W przypadku bind-frontów zmienne **zawsze** zostaną przekazane poprzez wartość</div>
</div><!-- fragment --><p> c 5 =&gt; mut int a; (a) -&gt;&gt; add =&gt; [int::int] adda; 5 -&gt; adda; // 10 1 =&gt; a; 5 -&gt; adda; // 10 </p><div class="fragment"><div class="line">### 1.11 Złożone konstrukcje</div>
<div class="line"> </div>
<div class="line">1. `Hello World`</div>
</div><!-- fragment --><p> c int main { ("Hello World") -&gt; stdout; ret 1; } </p><div class="fragment"><div class="line">2. `quadratic`</div>
</div><!-- fragment --><p> c int main { ("Enter a ")-&gt;stdin =&gt; flt a; ("Enter b ")-&gt;stdin =&gt; flt b; ("Enter c ")-&gt;stdin =&gt; flt c;</p>
<p>b * b - 4 * a * c =&gt; mut flt delta;</p>
<p>if (delta &gt; 0) { (delta)-&gt;sqrt; (-b - delta) / (2 * a) =&gt; flt x1; (-b + delta) / (2 * a) =&gt; flt x2;</p>
<p>("Result: ") -&gt; stdout; (x1 + " and " + x2 + "\n") -&gt; stdout; } elif (delta == 0) { -b / 2 * a =&gt; flt x1; ("Result: " + x1 + "\n") -&gt; stdout; } else { ("No real solution\n") -&gt; stdout; } ret 0; } </p><div class="fragment"><div class="line">3. Recursive sum of n natural numbers</div>
</div><!-- fragment --><p> c int recur_sum::int n { if (n &lt;= 1) { ret n; } ret ((n - 1) -&gt; recur_sum) + n; }</p>
<p>int main { ("Podaj n: ") -&gt; stdin =&gt; int n; ("suma to: " + (n)-&gt;recur_sum + "\n")-&gt;stdout; ret 0; } </p><div class="fragment"><div class="line">## 2. Formalna specyfikacja i składnia (EBNF)</div>
</div><!-- fragment --><p> ebnf start_symbol = {statement}</p>
<p>function_def = func_signature, block func_signature = type, identifier, [function_sign_op, function_def_params] function_def_params = function_param, {",", function_param} function_param = type_non_void, identifier</p>
<p>statement = operation | if_statement | for_loop | while_loop | return_statement | function_def</p>
<p>return_statement = ret, [expression], ";"</p>
<p>while_loop = while, "(", expression, ")", block for_loop = for, for_loop_args, block, call_op, bind_front, ";" for_loop_args = "(", (identifier | assignment), ";", expression, ")"</p>
<p>if_statement = if, "(", expression, ")", block, {elif_st}, [else_st] else_st = else, block, elif_st = elif, "(", expression, ")", block</p>
<p>block = "{", {statement}, "}"</p>
<p>assignment = assignable, assign_op, [type_non_void_mut], identifier, ";"</p>
<p>expression = logical_expression logical_expression = comp_expression, [logical_and_or, comp_expression] comp_expression = additive_expression, [comp_operator, additive_expression] additive_expression = term, {add_sub_op, term} term = unary_factor, {mult_div_op, unary_factor} unary_factor = [unary_operator], factor factor = function_call | wildcard | number | identifier | string | "(" expression ")"</p>
<p>function_call = function_args, call_op, callable callable = bind_front | function_call function_args = "(", [func_arg_list], ")"</p>
<p>bind_front = [func_arg_list, bindfrt_op], decorator decorator = identifier, [decoration_op, identifier]</p>
<p>func_arg_list = expression, {",", expression}</p>
<p>type = type_non_void | void type_non_void = var_type | func_type</p>
<p>var_type_mut = [mut], var_type var_type = int | flt | string | bool | func_type func_type = "[", type_mut, function_sign_op, func_type_args, "]" func_type_args = type_non_void_mut, {",", type_non_void_mut} </p><div class="fragment"></div><!-- fragment --><p> ebnf identifier = letter, {letter | digit | "_"}</p>
<p>string = '"', {character | escape} '"' escape = escape_op, escape_sequence</p>
<p>character = letter | digit | special_character</p>
<p>number = float | integer</p>
<p>float = integer, ".", {digit} integer = zero | non_zero, {digit}</p>
<p>funcn_sign_op = "::" if = "if" elif = "elif" else = "else" while = "while" for = "for" ret = "ret"</p>
<p>assign_op = "=&gt;" bindfrt_op = "-&gt;&gt;" decoration_op = "@" call_op = "-&gt;"</p>
<p>int = "int" flt = "flt" string = "string" bool = "bool" void = "void"</p>
<p>mut = "mut"</p>
<p>bool_type = "true" | "false"</p>
<p>wildcard = "_"</p>
<p>unary_operator = "!" | "-"</p>
<p>comp_operator = "&gt;" | "&lt;" | "&gt;=" | "&lt;=" | "!="</p>
<p>logical_and_or = "&amp;&amp;" | "||"</p>
<p>mult_div_op = "*" | "/"</p>
<p>add_sub_op = "-" | "+"</p>
<p>escape_op = "\"

escape_sequence = "n" 
                | "t"
                | "r"
                | "" | '"'</p>
<p>special_char = " " | "!" | "#" | "$" | "%" | "&amp;" | "'" | "(" | ")" | "*" | "+" | "," | "-" | "." | "/" | ":" | ";" | "&lt;" | "=" | "&gt;" | "?" | "@" | "[" | "]" | "^" | "_" | "`" | "{" | "|" | "}" | "~"</p>
<p>letter = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "R" | "S" | "T" | "Q" | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "r" | "s" | "t" | "q" | "u" | "v" | "w" | "x" | "y" | "z"</p>
<p>digit = non_zero | zero non_zero = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" zero = "0" </p><div class="fragment"><div class="line">## 3. Obsługa błędów</div>
<div class="line"> </div>
<div class="line">Każdy z etapów kompilacji zgłasza wyjątki</div>
<div class="line"> </div>
<div class="line">Poniżej przedstawiono wyciąg z programu w przypadku wystąpienia typowych błędów kompilacji</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">### 3.1 Analizator Leksykalny (Przykłady błędów i zachowanie)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">1. Niepoprawny identyfikator (*Unexpected Token*)</div>
</div><!-- fragment --><p> [TOKEN: [<a class="el" href="classType.html" title="Abstract class representing a Type.">Type</a>: T_INT_TYPE, Value: None, <a class="el" href="classPosition.html" title="a class representing a position in the source document">Position</a>: 1:1] [TOKEN: [<a class="el" href="classType.html" title="Abstract class representing a Type.">Type</a>: T_IDENTIFIER, Value: main, <a class="el" href="classPosition.html" title="a class representing a position in the source document">Position</a>: 1:5] [TOKEN: [<a class="el" href="classType.html" title="Abstract class representing a Type.">Type</a>: T_LBLOCK, Value: None, <a class="el" href="classPosition.html" title="a class representing a position in the source document">Position</a>: 1:10] [TOKEN: [<a class="el" href="classType.html" title="Abstract class representing a Type.">Type</a>: T_INT, Value: 0, <a class="el" href="classPosition.html" title="a class representing a position in the source document">Position</a>: 2:5] [TOKEN: [<a class="el" href="classType.html" title="Abstract class representing a Type.">Type</a>: T_ASSIGN, Value: None, <a class="el" href="classPosition.html" title="a class representing a position in the source document">Position</a>: 2:7] [TOKEN: [<a class="el" href="classType.html" title="Abstract class representing a Type.">Type</a>: T_INT_TYPE, Value: None, <a class="el" href="classPosition.html" title="a class representing a position in the source document">Position</a>: 2:10] [TOKEN: [<a class="el" href="classType.html" title="Abstract class representing a Type.">Type</a>: T_IDENTIFIER, Value: a, <a class="el" href="classPosition.html" title="a class representing a position in the source document">Position</a>: 2:14] ERROR: Unexpected token </p><div class="fragment"><div class="line">2. Identyfikator jest słowem kluczowym</div>
</div><!-- fragment --><p> Error: Exception thrown at 2:14 - Expected identifier 1 | int main { </p><blockquote class="doxtable">
<p>&zwj;2 | 0 =&gt; int if; ^ Exception thrown at 2:14 - Expected identifier 3 | ret 0; </p>
</blockquote>
<div class="fragment"><div class="line">- Nieznany symbol zostanie zastąpiony symbolem &quot;_&quot;</div>
<div class="line"> </div>
<div class="line">3. Niewłaściwy operator</div>
</div><!-- fragment --><p> [TOKEN: [<a class="el" href="classType.html" title="Abstract class representing a Type.">Type</a>: T_INT_TYPE, Value: None, <a class="el" href="classPosition.html" title="a class representing a position in the source document">Position</a>: 1:1] [TOKEN: [<a class="el" href="classType.html" title="Abstract class representing a Type.">Type</a>: T_IDENTIFIER, Value: main, <a class="el" href="classPosition.html" title="a class representing a position in the source document">Position</a>: 1:5] [TOKEN: [<a class="el" href="classType.html" title="Abstract class representing a Type.">Type</a>: T_LBLOCK, Value: None, <a class="el" href="classPosition.html" title="a class representing a position in the source document">Position</a>: 1:10] [TOKEN: [<a class="el" href="classType.html" title="Abstract class representing a Type.">Type</a>: T_INT, Value: 0, <a class="el" href="classPosition.html" title="a class representing a position in the source document">Position</a>: 2:5] ERROR: Unexpected token </p><div class="fragment"><div class="line">- Wyrażenie zostanie zastąpione wyrażeniem `0`</div>
<div class="line"> </div>
<div class="line">### 3.2 Analizator Składniowy</div>
</div><!-- fragment --><p> c Error: Exception thrown at 3:5 - Expected ';' 2 | 0 =&gt; int sth </p><blockquote class="doxtable">
<p>&zwj;3 | ret 0; ^ Exception thrown at 3:5 - Expected ';' 4 | } </p>
</blockquote>
<div class="fragment"></div><!-- fragment --><p> c Error: Exception thrown at 1:10 - Expected '::' </p><blockquote class="doxtable">
<p>&zwj;1 | int main abc ^ Exception thrown at 1:10 - Expected '::' </p>
</blockquote>
<div class="fragment"></div><!-- fragment --><p> c Error: Exception thrown at 1:13 - Expected type </p><blockquote class="doxtable">
<p>&zwj;1 | int main :: { ^ Exception thrown at 1:13 - Expected type 2 | ret 0; </p>
</blockquote>
<div class="fragment"><div class="line">### 3.3 Analizator Semantyczny</div>
</div><!-- fragment --><p> Error: Exception thrown at 2:5 - Unsupported operator for type 1 | int main { </p><blockquote class="doxtable">
<p>&zwj;2 | "abc" - 1 =&gt; int result; ^ Exception thrown at 2:5 - Unsupported operator for type 3 | } </p>
</blockquote>
<div class="fragment"></div><!-- fragment --><p> Error: Exception thrown at 2:5 - <a class="el" href="structVariable.html" title="the variable definition">Variable</a> not in scope: a 1 | int main { </p><blockquote class="doxtable">
<p>&zwj;2 | 5 =&gt; a; ^ Exception thrown at 2:5 - <a class="el" href="structVariable.html" title="the variable definition">Variable</a> not in scope: a 3 | } </p>
</blockquote>
<div class="fragment"></div><!-- fragment --><p> Error: Exception thrown at 2:12 - Unknown identifier 1 | int main { </p><blockquote class="doxtable">
<p>&zwj;2 | (5) -&gt; some_func; ^ Exception thrown at 2:12 - Unknown identifier 3 | } </p>
</blockquote>
<div class="fragment"></div><!-- fragment --><p> Error: Exception thrown at 2:9 - Invalid argument vector size 1 | int main { </p><blockquote class="doxtable">
<p>&zwj;2 | (5) -&gt; some_func; ^ Exception thrown at 2:9 - Invalid argument vector size 3 | } </p>
</blockquote>
<div class="fragment"></div><!-- fragment --><p> Error: Exception thrown at 2:15 - Invalid argument vector size 1 | int main { </p><blockquote class="doxtable">
<p>&zwj;2 | (1, 2, 3) -&gt; some_func; ^ Exception thrown at 2:15 - Invalid argument vector size 3 | } </p>
</blockquote>
<div class="fragment"><div class="line">## 4. Sposób uruchomienia, I/O</div>
<div class="line"> </div>
<div class="line">Kompilator przyjmie na wejście plik źródłowy lub tekst z wejścia standardowego.</div>
<div class="line"> </div>
<div class="line">Sposób uruchamiania dla plików źródłowych będzie następujący:</div>
</div><!-- fragment --><p> &lt;nazwa programu&gt; &lt;pliki źródłowe&gt; &lt;flagi&gt; ```</p>
<h1><a class="anchor" id="autotoc_md9"></a>
5. Opis sposobu testowania</h1>
<p>Wszystkie testy zostały wykonane z użyciem biblioteki <code>gtest</code>, sposób testowania oraz przetestowane elementy kodu zostały opisane poniżej</p>
<h2><a class="anchor" id="autotoc_md10"></a>
5.1 Analizator Leksykalny</h2>
<p>Przetestowane zostały wszystkie możliwe typy tokenów oraz sytuacje w których działanie leksera kończy się błedem.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
5.2 Analizator Składniowy</h2>
<p>Testy parera obejmują 3 części:</p><ul>
<li>złożone konstrukcje</li>
<li>proste konstrukcje i ich kombinacje</li>
<li>sytuacje zwracające wyjątki</li>
</ul>
<p>Każda z tych części została przetestowana przy użyciu wizytatora zliczającego wystąpienia poszczególnych elementów drzewa. Testy sparametryzowane obejmują prawie 200 permutacji wyrażeń oraz zdań oraz bardzo dużą ilość błędnie napisanych programów przy których spodziewamy się rzuczenia wyjątku.</p>
<p>Złożone konstrukcje obejmują większe programy, takie jak opisany wyżej program obliczający rozwiązanie równań kwadratowych</p>
<h2><a class="anchor" id="autotoc_md12"></a>
5.3 Interpreter</h2>
<p>Testy interpretera obejmują zbiór przykładowych programów zawierających wszystkie konstrukcje w języku, sparametryzowane testy wyrażeń oraz przykładowe błędne programy. Sprawdzają one poprawność (lub niepoprawność) wyników zwracanych przez programy. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
