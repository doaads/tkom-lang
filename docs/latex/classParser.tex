\doxysection{Parser Class Reference}
\hypertarget{classParser}{}\label{classParser}\index{Parser@{Parser}}


A class responsible for parsing source code into a program tree.  




{\ttfamily \#include $<$parser.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classParser_a453dea22865a0e18240ec4efd61c07a8}{Parser}} (std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classLexer}{Lexer}} $>$ \mbox{\hyperlink{classParser_a2f50c2893fdecbd0cb8e7d7a465e4f3a}{lexer}})
\begin{DoxyCompactList}\small\item\em Constructs a parser with a lexer. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a36fe89159601be46fe6a7031896a91f9}{parse}} () -\/$>$ Program\+Ptr
\begin{DoxyCompactList}\small\item\em Starts parsing and returns a full program tree. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a4d40bc258bbc03c5068c22839a994aa3}{parse\+\_\+statement}} () -\/$>$ Statement\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a single statement. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a3765ab1d438463290e311c32b0754668}{parse\+\_\+expression}} () -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses an expression. \end{DoxyCompactList}\item 
\Hypertarget{classParser_aa9d77f13b9067eb48671d674b8a2f993}\label{classParser_aa9d77f13b9067eb48671d674b8a2f993} 
void {\bfseries next\+\_\+token} ()
\begin{DoxyCompactList}\small\item\em Advances to the next token. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Condition\+Func, typename Next\+Func$>$ }\\auto \mbox{\hyperlink{classParser_ac644b96034d838efedd1360d5ab2d1f5}{parse\+\_\+binary\+\_\+expr}} (Condition\+Func condition, Next\+Func next, bool limited=false) -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a binary expression using given condition and next-\/step logic. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a10fa8f1fbd7cb37efdba9b9f1fec9bb2}{parse\+\_\+func\+\_\+def}} () -\/$>$ Func\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a function definition. {\ttfamily function\+\_\+def = func\+\_\+signature, block} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a617a11e0305450dfb73e517ae2afa86d}{parse\+\_\+func\+\_\+signature}} () -\/$>$ Func\+Sign\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a function signature. {\ttfamily func\+\_\+signature = type, identifier, \mbox{[}function\+\_\+sign\+\_\+op, function\+\_\+def\+\_\+params\mbox{]}} {\ttfamily func\+\_\+def\+\_\+params = type\+\_\+non\+\_\+void, identifier, \{"{},"{}, type\+\_\+non\+\_\+void, identifier\}} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a24abe38441c2a2fccb60e20f074e841f}{parse\+\_\+func\+\_\+param}} () -\/$>$ Param\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a function parameter. {\ttfamily func\+\_\+param = type\+\_\+non\+\_\+void, identifier} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a64d09ac80f0bb0358cdb40b808b6050f}{parse\+\_\+block}} () -\/$>$ Block\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a block of code. {\ttfamily block = "{}\{"{}, \{statement\}, "{}\}"{}} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_adf3894b98d5d7843533382effea83913}{parse\+\_\+or\+\_\+expression}} () -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses an OR expression (logical OR). {\ttfamily or\+\_\+expression = and\+\_\+expression, \{logical\+\_\+or, and\+\_\+expression\}} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a7f9f59d0b9265a1edef5cfca25b34b61}{parse\+\_\+and\+\_\+expression}} () -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses an AND expression (logical AND). {\ttfamily and\+\_\+expression = comp\+\_\+expression, \{logical\+\_\+and, comp\+\_\+expression\}} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a0339b7c050c56ed9baa362680849e7e2}{parse\+\_\+comp\+\_\+expression}} () -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a comparative expression (e.\+g., equality, relational operators). {\ttfamily comp\+\_\+expression = additive\+\_\+expression, \mbox{[}comp\+\_\+operator, additive\+\_\+expression\mbox{]}} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a7f0a6022640765058ad962ccba198467}{parse\+\_\+additive\+\_\+expression}} () -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses an additive expression (addition, subtraction). {\ttfamily additive\+\_\+expression = term, \{add\+\_\+sub\+\_\+op, term\}} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_af7b27a75d600ee5e546f80a3828f8221}{parse\+\_\+term}} () -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a term (multiplication, division). {\ttfamily term = unary\+\_\+factor, \{mult\+\_\+div\+\_\+op, unary\+\_\+factor\}} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a64b01431ae2ca929d115d3e4c359aea5}{parse\+\_\+unary}} () -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a unary expression (negation, logical NOT). \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a0303c15cf9ebfa053bca7f2af5fa5573}{parse\+\_\+factor}} () -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a factor (base of expressions like numbers or identifiers). {\ttfamily factor = function\+\_\+call} {\ttfamily \texorpdfstring{$\vert$}{|} bind\+\_\+front} {\ttfamily \texorpdfstring{$\vert$}{|} decorator} {\ttfamily \texorpdfstring{$\vert$}{|} number} {\ttfamily \texorpdfstring{$\vert$}{|} identifier} {\ttfamily \texorpdfstring{$\vert$}{|} string} {\ttfamily \texorpdfstring{$\vert$}{|} "{}("{} expression "{})"{}} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_aa7419a9e21d529d9af2e3d9878ac9ef6}{parse\+\_\+func\+\_\+call\+\_\+or\+\_\+parens}} () -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a function call or a parenthesized expression. {\ttfamily function\+\_\+call = function\+\_\+args, call\+\_\+op, bind\+\_\+front} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_af1dc912ef6817a93ec6aa7aa0ac8fe38}{parse\+\_\+assign\+\_\+or\+\_\+call}} () -\/$>$ Statement\+Ptr
\begin{DoxyCompactList}\small\item\em Parses an assignment or a function call statement. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a9415a0e2546d9ec38b5ab40d5563c88a}{parse\+\_\+conditional\+\_\+statement}} (Token\+Type st\+\_\+type) -\/$>$ Statement\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a conditional statement (if/else). {\ttfamily if\+\_\+statement = if, condition, block, \mbox{[}elif\+\_\+st \texorpdfstring{$\vert$}{|} else\+\_\+st\mbox{]}} {\ttfamily elif\+\_\+st = elif, condition, block, \mbox{[}elif\+\_\+st \texorpdfstring{$\vert$}{|} else\+\_\+st\mbox{]}} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_ab7a63c75987e69681b3f8b56471d2e9c}{parse\+\_\+else\+\_\+statement}} () -\/$>$ Statement\+Ptr
\begin{DoxyCompactList}\small\item\em Parses an else statement. {\ttfamily else\+\_\+st = else, block} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a21578bd901d6e33df8bde03a0e4164a6}{parse\+\_\+for\+\_\+loop}} () -\/$>$ Statement\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a for loop statement. {\ttfamily for\+\_\+loop = for, for\+\_\+loop\+\_\+args, block, call\+\_\+op, bind\+\_\+front, "{};"{}} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a4a4c1600d6a23d2213ec68e9006774e1}{parse\+\_\+for\+\_\+loop\+\_\+args}} () -\/$>$ For\+Loop\+Args\+Ptr
\begin{DoxyCompactList}\small\item\em Parses the arguments for a for loop. {\ttfamily for\+\_\+loop\+\_\+args = "{}("{}, (identifier \texorpdfstring{$\vert$}{|} assignment), "{};"{}, expression, "{})"{}} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a126a309ba0da0a1ae7c7ddc2e5b5ad3b}{parse\+\_\+while\+\_\+loop}} () -\/$>$ Statement\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a while loop statement. {\ttfamily while\+\_\+loop = while, condition, block} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a35e82cd54a8118d86990f8ffc1aaa7d8}{parse\+\_\+ret\+\_\+statement}} () -\/$>$ Statement\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a return statement. \`{}ret\+\_\+statement = ret, expression, "{};"{}. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_abf7509e8578883bd7ddf3450ce476202}{parse\+\_\+condition}} () -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses the condition for conditional or loop statements. {\ttfamily condition = "{}("{}, expresion, "{})"{}} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_ae6db9de57b961c1898de70bca4da2308}{parse\+\_\+bindfrt\+\_\+or\+\_\+call}} (std\+::vector$<$ Expr\+Ptr $>$ \&args) -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a bind front-\/right or function call. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_ab3f359319dd90d468551233effe979c0}{parse\+\_\+bind\+\_\+front\+\_\+right}} (std\+::vector$<$ Expr\+Ptr $>$ \&args) -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a bind front-\/right expression. {\ttfamily bind\+\_\+front = \mbox{[}func\+\_\+args, bindfrt\+\_\+op\mbox{]}, decorator} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a4aeb49963af6d6024f28d8c8b697fef9}{parse\+\_\+bind\+\_\+front}} () -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a bind front expression. {\ttfamily bind\+\_\+front = \mbox{[}func\+\_\+args, bindfrt\+\_\+op\mbox{]}, decorator} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a3a739303ba9080489a5d6b4093adb7ba}{parse\+\_\+decorator}} () -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a decorator expression. {\ttfamily decorator = identifier, \mbox{[}decorate\+\_\+op, identifier\mbox{]}} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a4080c65b8d03d5d84ae6575fb292869e}{parse\+\_\+identifier}} () -\/$>$ Expr\+Ptr
\begin{DoxyCompactList}\small\item\em Parses an identifier expression. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_ad79892ddd65155e0587a4d0da44c20d0}{parse\+\_\+type}} (bool allow\+\_\+void=false) -\/$>$ Type\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a type expression (e.\+g., int, void). {\ttfamily type = type\+\_\+non\+\_\+void \texorpdfstring{$\vert$}{|} void} {\ttfamily type\+\_\+non\+\_\+void = var\+\_\+type \texorpdfstring{$\vert$}{|} func\+\_\+type} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_aac1e782dcb39f2d695a8e4b4e1e7cd83}{parse\+\_\+var\+\_\+type}} (bool allow\+\_\+void) -\/$>$ Type\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a variable type. {\ttfamily var\+\_\+type\+\_\+mut = \mbox{[}mut\mbox{]} var\+\_\+type} {\ttfamily var\+\_\+type = int} {\ttfamily \texorpdfstring{$\vert$}{|} flt} {\ttfamily \texorpdfstring{$\vert$}{|} string} {\ttfamily \texorpdfstring{$\vert$}{|} bool} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a2cf88fbf89845a671a251f44cee0bf6c}{parse\+\_\+func\+\_\+type}} () -\/$>$ Type\+Ptr
\begin{DoxyCompactList}\small\item\em Parses a function type. {\ttfamily func\+\_\+type = "{}\mbox{[}"{}, type, function\+\_\+sign\+\_\+op, func\+\_\+type\+\_\+args} {\ttfamily func\+\_\+type\+\_\+args = type\+\_\+non\+\_\+void, \{"{},"{}, type\+\_\+non\+\_\+void\}} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_abccbf315c3c3cc86fec36985f35baa78}{parse\+\_\+func\+\_\+args}} () -\/$>$ std\+::optional$<$ std\+::vector$<$ Expr\+Ptr $>$ $>$
\begin{DoxyCompactList}\small\item\em Parses function arguments. {\ttfamily func\+\_\+args = "{}("{}, \mbox{[}function\+\_\+arg\+\_\+list\mbox{]}, "{})"{}} {\ttfamily function\+\_\+arg\+\_\+list = expression, \{"{},"{}, expression\}} \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a1bd9561940797917834dcc89455f875f}{is\+\_\+comparative}} (Token\+Type type) const -\/$>$ bool
\begin{DoxyCompactList}\small\item\em Checks if the given token is a comparative operator. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a7117307f8995892c3c801cc3c8afc959}{is\+\_\+factor}} (Token\+Type type) const -\/$>$ bool
\begin{DoxyCompactList}\small\item\em Checks if the given token is a factor operator. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a319041d4631197a92fbc39c3961fda20}{is\+\_\+type}} (Token\+Type type) const -\/$>$ bool
\begin{DoxyCompactList}\small\item\em Checks if the given token represents a type. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_aa86116637776ba61c159db3451017b90}{is\+\_\+type\+\_\+or\+\_\+void}} (Token\+Type type) const -\/$>$ bool
\begin{DoxyCompactList}\small\item\em Checks if the given token represents a type or void. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_a8fda9fc2049798bd0f9ba6f146f86c56}{is\+\_\+next\+\_\+token}} (Token\+Type type) -\/$>$ bool
\begin{DoxyCompactList}\small\item\em Checks if the next token is of the specified type. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_ad9dcf6e6e1b65d727b5acb1b204ac05c}{was\+\_\+last\+\_\+token}} (Token\+Type type) -\/$>$ bool
\begin{DoxyCompactList}\small\item\em Checks if the last token was of the specified type. \end{DoxyCompactList}\item 
auto \mbox{\hyperlink{classParser_aaa9c437e2194d4b1eb9e73930e98c47f}{is\+\_\+token}} (Token\+Type type) const -\/$>$ bool
\begin{DoxyCompactList}\small\item\em Checks if the current token matches the specified type. \end{DoxyCompactList}\item 
\Hypertarget{classParser_a22b5636eafdf4ca69431a18dac4ba6be}\label{classParser_a22b5636eafdf4ca69431a18dac4ba6be} 
auto {\bfseries get\+\_\+position} () const -\/$>$ const \mbox{\hyperlink{classPosition}{Position}}
\item 
\Hypertarget{classParser_a18ac4f107c13e5a312ffca5ec7b04762}\label{classParser_a18ac4f107c13e5a312ffca5ec7b04762} 
{\footnotesize template$<$typename T$>$ }\\auto {\bfseries shall} (T arg, std\+::string error) -\/$>$ T
\end{DoxyCompactItemize}
\doxysubsubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classParser_a2f50c2893fdecbd0cb8e7d7a465e4f3a}\label{classParser_a2f50c2893fdecbd0cb8e7d7a465e4f3a} 
std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classLexer}{Lexer}} $>$ {\bfseries lexer}
\begin{DoxyCompactList}\small\item\em Source lexer for tokens. \end{DoxyCompactList}\item 
\Hypertarget{classParser_a21ea3fca7b244f80d61baa44d145d3c6}\label{classParser_a21ea3fca7b244f80d61baa44d145d3c6} 
\mbox{\hyperlink{classToken}{Token}} {\bfseries current\+\_\+token}
\begin{DoxyCompactList}\small\item\em Current token being processed. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A class responsible for parsing source code into a program tree. 

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classParser_a453dea22865a0e18240ec4efd61c07a8}\index{Parser@{Parser}!Parser@{Parser}}
\index{Parser@{Parser}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{Parser()}{Parser()}}
{\footnotesize\ttfamily \label{classParser_a453dea22865a0e18240ec4efd61c07a8} 
Parser\+::\+Parser (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \mbox{\hyperlink{classLexer}{Lexer}} $>$}]{lexer}{}\end{DoxyParamCaption})}



Constructs a parser with a lexer. 


\begin{DoxyParams}{Parameters}
{\em lexer} & Shared pointer to the lexer. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\Hypertarget{classParser_a1bd9561940797917834dcc89455f875f}\index{Parser@{Parser}!is\_comparative@{is\_comparative}}
\index{is\_comparative@{is\_comparative}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{is\_comparative()}{is\_comparative()}}
{\footnotesize\ttfamily \label{classParser_a1bd9561940797917834dcc89455f875f} 
auto Parser\+::is\+\_\+comparative (\begin{DoxyParamCaption}\item[{Token\+Type}]{type}{}\end{DoxyParamCaption}) const -\/$>$ bool\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [private]}}



Checks if the given token is a comparative operator. 


\begin{DoxyParams}{Parameters}
{\em type} & The token type to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the token is a comparative operator, false otherwise. 
\end{DoxyReturn}
\Hypertarget{classParser_a7117307f8995892c3c801cc3c8afc959}\index{Parser@{Parser}!is\_factor@{is\_factor}}
\index{is\_factor@{is\_factor}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{is\_factor()}{is\_factor()}}
{\footnotesize\ttfamily \label{classParser_a7117307f8995892c3c801cc3c8afc959} 
auto Parser\+::is\+\_\+factor (\begin{DoxyParamCaption}\item[{Token\+Type}]{type}{}\end{DoxyParamCaption}) const -\/$>$ bool\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [private]}}



Checks if the given token is a factor operator. 


\begin{DoxyParams}{Parameters}
{\em type} & The token type to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the token is a factor operator, false otherwise. 
\end{DoxyReturn}
\Hypertarget{classParser_a8fda9fc2049798bd0f9ba6f146f86c56}\index{Parser@{Parser}!is\_next\_token@{is\_next\_token}}
\index{is\_next\_token@{is\_next\_token}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{is\_next\_token()}{is\_next\_token()}}
{\footnotesize\ttfamily \label{classParser_a8fda9fc2049798bd0f9ba6f146f86c56} 
auto Parser\+::is\+\_\+next\+\_\+token (\begin{DoxyParamCaption}\item[{Token\+Type}]{type}{}\end{DoxyParamCaption}) -\/$>$ bool\hspace{0.3cm}{\ttfamily [private]}}



Checks if the next token is of the specified type. 


\begin{DoxyParams}{Parameters}
{\em type} & The token type to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the next token matches the given type, false otherwise. 
\end{DoxyReturn}
\Hypertarget{classParser_aaa9c437e2194d4b1eb9e73930e98c47f}\index{Parser@{Parser}!is\_token@{is\_token}}
\index{is\_token@{is\_token}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{is\_token()}{is\_token()}}
{\footnotesize\ttfamily \label{classParser_aaa9c437e2194d4b1eb9e73930e98c47f} 
auto Parser\+::is\+\_\+token (\begin{DoxyParamCaption}\item[{Token\+Type}]{type}{}\end{DoxyParamCaption}) const -\/$>$ bool\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [private]}}



Checks if the current token matches the specified type. 


\begin{DoxyParams}{Parameters}
{\em type} & The token type to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the current token matches the given type, false otherwise. 
\end{DoxyReturn}
\Hypertarget{classParser_a319041d4631197a92fbc39c3961fda20}\index{Parser@{Parser}!is\_type@{is\_type}}
\index{is\_type@{is\_type}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{is\_type()}{is\_type()}}
{\footnotesize\ttfamily \label{classParser_a319041d4631197a92fbc39c3961fda20} 
auto Parser\+::is\+\_\+type (\begin{DoxyParamCaption}\item[{Token\+Type}]{type}{}\end{DoxyParamCaption}) const -\/$>$ bool\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [private]}}



Checks if the given token represents a type. 


\begin{DoxyParams}{Parameters}
{\em type} & The token type to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the token represents a type, false otherwise. 
\end{DoxyReturn}
\Hypertarget{classParser_aa86116637776ba61c159db3451017b90}\index{Parser@{Parser}!is\_type\_or\_void@{is\_type\_or\_void}}
\index{is\_type\_or\_void@{is\_type\_or\_void}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{is\_type\_or\_void()}{is\_type\_or\_void()}}
{\footnotesize\ttfamily \label{classParser_aa86116637776ba61c159db3451017b90} 
auto Parser\+::is\+\_\+type\+\_\+or\+\_\+void (\begin{DoxyParamCaption}\item[{Token\+Type}]{type}{}\end{DoxyParamCaption}) const -\/$>$ bool\hspace{0.3cm}{\ttfamily [nodiscard]}, {\ttfamily [private]}}



Checks if the given token represents a type or void. 


\begin{DoxyParams}{Parameters}
{\em type} & The token type to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the token represents a type or void, false otherwise. 
\end{DoxyReturn}
\Hypertarget{classParser_a36fe89159601be46fe6a7031896a91f9}\index{Parser@{Parser}!parse@{parse}}
\index{parse@{parse}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse()}{parse()}}
{\footnotesize\ttfamily \label{classParser_a36fe89159601be46fe6a7031896a91f9} 
auto Parser\+::parse (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Program\+Ptr}



Starts parsing and returns a full program tree. 

\begin{DoxyReturn}{Returns}
Smart pointer to parsed program. 
\end{DoxyReturn}
\Hypertarget{classParser_a7f0a6022640765058ad962ccba198467}\index{Parser@{Parser}!parse\_additive\_expression@{parse\_additive\_expression}}
\index{parse\_additive\_expression@{parse\_additive\_expression}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_additive\_expression()}{parse\_additive\_expression()}}
{\footnotesize\ttfamily \label{classParser_a7f0a6022640765058ad962ccba198467} 
auto Parser\+::parse\+\_\+additive\+\_\+expression (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses an additive expression (addition, subtraction). {\ttfamily additive\+\_\+expression = term, \{add\+\_\+sub\+\_\+op, term\}} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed additive expression. 
\end{DoxyReturn}
\Hypertarget{classParser_a7f9f59d0b9265a1edef5cfca25b34b61}\index{Parser@{Parser}!parse\_and\_expression@{parse\_and\_expression}}
\index{parse\_and\_expression@{parse\_and\_expression}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_and\_expression()}{parse\_and\_expression()}}
{\footnotesize\ttfamily \label{classParser_a7f9f59d0b9265a1edef5cfca25b34b61} 
auto Parser\+::parse\+\_\+and\+\_\+expression (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses an AND expression (logical AND). {\ttfamily and\+\_\+expression = comp\+\_\+expression, \{logical\+\_\+and, comp\+\_\+expression\}} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed AND expression. 
\end{DoxyReturn}
\Hypertarget{classParser_af1dc912ef6817a93ec6aa7aa0ac8fe38}\index{Parser@{Parser}!parse\_assign\_or\_call@{parse\_assign\_or\_call}}
\index{parse\_assign\_or\_call@{parse\_assign\_or\_call}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_assign\_or\_call()}{parse\_assign\_or\_call()}}
{\footnotesize\ttfamily \label{classParser_af1dc912ef6817a93ec6aa7aa0ac8fe38} 
auto Parser\+::parse\+\_\+assign\+\_\+or\+\_\+call (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Statement\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses an assignment or a function call statement. 

{\ttfamily assignment = expression, assign\+\_\+op, \mbox{[}type\+\_\+non\+\_\+void\+\_\+mut\mbox{]}, identifier, "{};"{}} {\ttfamily expression\+\_\+st = expression, "{};"{}}

Parsed together due to common construction at start \begin{DoxyReturn}{Returns}
A unique pointer to the parsed statement. 
\end{DoxyReturn}
\Hypertarget{classParser_ac644b96034d838efedd1360d5ab2d1f5}\index{Parser@{Parser}!parse\_binary\_expr@{parse\_binary\_expr}}
\index{parse\_binary\_expr@{parse\_binary\_expr}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_binary\_expr()}{parse\_binary\_expr()}}
{\footnotesize\ttfamily \label{classParser_ac644b96034d838efedd1360d5ab2d1f5} 
template$<$typename Condition\+Func, typename Next\+Func$>$ \\
auto Parser\+::parse\+\_\+binary\+\_\+expr (\begin{DoxyParamCaption}\item[{Condition\+Func}]{condition}{, }\item[{Next\+Func}]{next}{, }\item[{bool}]{limited}{ = {\ttfamily false}}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a binary expression using given condition and next-\/step logic. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Condition\+Func} & \doxylink{classFunction}{Function} to check operator precedence. \\
\hline
{\em Next\+Func} & \doxylink{classFunction}{Function} to get the next expression level. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em condition} & Operator condition function. \\
\hline
{\em next} & Next parsing function. \\
\hline
{\em limited} & Whether to limit parsing scope. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Parsed expression. 
\end{DoxyReturn}
\Hypertarget{classParser_a4aeb49963af6d6024f28d8c8b697fef9}\index{Parser@{Parser}!parse\_bind\_front@{parse\_bind\_front}}
\index{parse\_bind\_front@{parse\_bind\_front}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_bind\_front()}{parse\_bind\_front()}}
{\footnotesize\ttfamily \label{classParser_a4aeb49963af6d6024f28d8c8b697fef9} 
auto Parser\+::parse\+\_\+bind\+\_\+front (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a bind front expression. {\ttfamily bind\+\_\+front = \mbox{[}func\+\_\+args, bindfrt\+\_\+op\mbox{]}, decorator} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed bind front expression. 
\end{DoxyReturn}
\Hypertarget{classParser_ab3f359319dd90d468551233effe979c0}\index{Parser@{Parser}!parse\_bind\_front\_right@{parse\_bind\_front\_right}}
\index{parse\_bind\_front\_right@{parse\_bind\_front\_right}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_bind\_front\_right()}{parse\_bind\_front\_right()}}
{\footnotesize\ttfamily \label{classParser_ab3f359319dd90d468551233effe979c0} 
auto Parser\+::parse\+\_\+bind\+\_\+front\+\_\+right (\begin{DoxyParamCaption}\item[{std\+::vector$<$ Expr\+Ptr $>$ \&}]{args}{}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a bind front-\/right expression. {\ttfamily bind\+\_\+front = \mbox{[}func\+\_\+args, bindfrt\+\_\+op\mbox{]}, decorator} 


\begin{DoxyParams}{Parameters}
{\em args} & The arguments for the bind front-\/right expression. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Expr\+Ptr if function succeeds, if it does not -\/ it returns the argument vector to previous owner 
\end{DoxyReturn}
\Hypertarget{classParser_ae6db9de57b961c1898de70bca4da2308}\index{Parser@{Parser}!parse\_bindfrt\_or\_call@{parse\_bindfrt\_or\_call}}
\index{parse\_bindfrt\_or\_call@{parse\_bindfrt\_or\_call}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_bindfrt\_or\_call()}{parse\_bindfrt\_or\_call()}}
{\footnotesize\ttfamily \label{classParser_ae6db9de57b961c1898de70bca4da2308} 
auto Parser\+::parse\+\_\+bindfrt\+\_\+or\+\_\+call (\begin{DoxyParamCaption}\item[{std\+::vector$<$ Expr\+Ptr $>$ \&}]{args}{}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a bind front-\/right or function call. 


\begin{DoxyParams}{Parameters}
{\em args} & The arguments for the bind front-\/right or function call. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Expr\+Ptr if function succeeds, if it does not -\/ it returns the argument vector to previous owner 
\end{DoxyReturn}
\Hypertarget{classParser_a64d09ac80f0bb0358cdb40b808b6050f}\index{Parser@{Parser}!parse\_block@{parse\_block}}
\index{parse\_block@{parse\_block}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_block()}{parse\_block()}}
{\footnotesize\ttfamily \label{classParser_a64d09ac80f0bb0358cdb40b808b6050f} 
auto Parser\+::parse\+\_\+block (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Block\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a block of code. {\ttfamily block = "{}\{"{}, \{statement\}, "{}\}"{}} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed block. 
\end{DoxyReturn}
\Hypertarget{classParser_a0339b7c050c56ed9baa362680849e7e2}\index{Parser@{Parser}!parse\_comp\_expression@{parse\_comp\_expression}}
\index{parse\_comp\_expression@{parse\_comp\_expression}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_comp\_expression()}{parse\_comp\_expression()}}
{\footnotesize\ttfamily \label{classParser_a0339b7c050c56ed9baa362680849e7e2} 
auto Parser\+::parse\+\_\+comp\+\_\+expression (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a comparative expression (e.\+g., equality, relational operators). {\ttfamily comp\+\_\+expression = additive\+\_\+expression, \mbox{[}comp\+\_\+operator, additive\+\_\+expression\mbox{]}} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed comparative expression. 
\end{DoxyReturn}
\Hypertarget{classParser_abf7509e8578883bd7ddf3450ce476202}\index{Parser@{Parser}!parse\_condition@{parse\_condition}}
\index{parse\_condition@{parse\_condition}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_condition()}{parse\_condition()}}
{\footnotesize\ttfamily \label{classParser_abf7509e8578883bd7ddf3450ce476202} 
auto Parser\+::parse\+\_\+condition (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses the condition for conditional or loop statements. {\ttfamily condition = "{}("{}, expresion, "{})"{}} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed condition expression. 
\end{DoxyReturn}
\Hypertarget{classParser_a9415a0e2546d9ec38b5ab40d5563c88a}\index{Parser@{Parser}!parse\_conditional\_statement@{parse\_conditional\_statement}}
\index{parse\_conditional\_statement@{parse\_conditional\_statement}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_conditional\_statement()}{parse\_conditional\_statement()}}
{\footnotesize\ttfamily \label{classParser_a9415a0e2546d9ec38b5ab40d5563c88a} 
auto Parser\+::parse\+\_\+conditional\+\_\+statement (\begin{DoxyParamCaption}\item[{Token\+Type}]{st\+\_\+type}{}\end{DoxyParamCaption}) -\/$>$ Statement\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a conditional statement (if/else). {\ttfamily if\+\_\+statement = if, condition, block, \mbox{[}elif\+\_\+st \texorpdfstring{$\vert$}{|} else\+\_\+st\mbox{]}} {\ttfamily elif\+\_\+st = elif, condition, block, \mbox{[}elif\+\_\+st \texorpdfstring{$\vert$}{|} else\+\_\+st\mbox{]}} 


\begin{DoxyParams}{Parameters}
{\em st\+\_\+type} & The type of the statement (if or else). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A unique pointer to the parsed conditional statement. 
\end{DoxyReturn}
\Hypertarget{classParser_a3a739303ba9080489a5d6b4093adb7ba}\index{Parser@{Parser}!parse\_decorator@{parse\_decorator}}
\index{parse\_decorator@{parse\_decorator}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_decorator()}{parse\_decorator()}}
{\footnotesize\ttfamily \label{classParser_a3a739303ba9080489a5d6b4093adb7ba} 
auto Parser\+::parse\+\_\+decorator (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a decorator expression. {\ttfamily decorator = identifier, \mbox{[}decorate\+\_\+op, identifier\mbox{]}} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed decorator expression. 
\end{DoxyReturn}
\Hypertarget{classParser_ab7a63c75987e69681b3f8b56471d2e9c}\index{Parser@{Parser}!parse\_else\_statement@{parse\_else\_statement}}
\index{parse\_else\_statement@{parse\_else\_statement}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_else\_statement()}{parse\_else\_statement()}}
{\footnotesize\ttfamily \label{classParser_ab7a63c75987e69681b3f8b56471d2e9c} 
auto Parser\+::parse\+\_\+else\+\_\+statement (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Statement\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses an else statement. {\ttfamily else\+\_\+st = else, block} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed else statement. 
\end{DoxyReturn}
\Hypertarget{classParser_a3765ab1d438463290e311c32b0754668}\index{Parser@{Parser}!parse\_expression@{parse\_expression}}
\index{parse\_expression@{parse\_expression}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_expression()}{parse\_expression()}}
{\footnotesize\ttfamily \label{classParser_a3765ab1d438463290e311c32b0754668} 
auto Parser\+::parse\+\_\+expression (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr}



Parses an expression. 

\begin{DoxyReturn}{Returns}
Smart pointer to parsed expression. 
\end{DoxyReturn}
\Hypertarget{classParser_a0303c15cf9ebfa053bca7f2af5fa5573}\index{Parser@{Parser}!parse\_factor@{parse\_factor}}
\index{parse\_factor@{parse\_factor}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_factor()}{parse\_factor()}}
{\footnotesize\ttfamily \label{classParser_a0303c15cf9ebfa053bca7f2af5fa5573} 
auto Parser\+::parse\+\_\+factor (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a factor (base of expressions like numbers or identifiers). {\ttfamily factor = function\+\_\+call} {\ttfamily \texorpdfstring{$\vert$}{|} bind\+\_\+front} {\ttfamily \texorpdfstring{$\vert$}{|} decorator} {\ttfamily \texorpdfstring{$\vert$}{|} number} {\ttfamily \texorpdfstring{$\vert$}{|} identifier} {\ttfamily \texorpdfstring{$\vert$}{|} string} {\ttfamily \texorpdfstring{$\vert$}{|} "{}("{} expression "{})"{}} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed factor expression. 
\end{DoxyReturn}
\Hypertarget{classParser_a21578bd901d6e33df8bde03a0e4164a6}\index{Parser@{Parser}!parse\_for\_loop@{parse\_for\_loop}}
\index{parse\_for\_loop@{parse\_for\_loop}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_for\_loop()}{parse\_for\_loop()}}
{\footnotesize\ttfamily \label{classParser_a21578bd901d6e33df8bde03a0e4164a6} 
auto Parser\+::parse\+\_\+for\+\_\+loop (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Statement\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a for loop statement. {\ttfamily for\+\_\+loop = for, for\+\_\+loop\+\_\+args, block, call\+\_\+op, bind\+\_\+front, "{};"{}} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed for loop statement. 
\end{DoxyReturn}
\Hypertarget{classParser_a4a4c1600d6a23d2213ec68e9006774e1}\index{Parser@{Parser}!parse\_for\_loop\_args@{parse\_for\_loop\_args}}
\index{parse\_for\_loop\_args@{parse\_for\_loop\_args}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_for\_loop\_args()}{parse\_for\_loop\_args()}}
{\footnotesize\ttfamily \label{classParser_a4a4c1600d6a23d2213ec68e9006774e1} 
auto Parser\+::parse\+\_\+for\+\_\+loop\+\_\+args (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ For\+Loop\+Args\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses the arguments for a for loop. {\ttfamily for\+\_\+loop\+\_\+args = "{}("{}, (identifier \texorpdfstring{$\vert$}{|} assignment), "{};"{}, expression, "{})"{}} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed for loop arguments. 
\end{DoxyReturn}
\Hypertarget{classParser_abccbf315c3c3cc86fec36985f35baa78}\index{Parser@{Parser}!parse\_func\_args@{parse\_func\_args}}
\index{parse\_func\_args@{parse\_func\_args}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_func\_args()}{parse\_func\_args()}}
{\footnotesize\ttfamily \label{classParser_abccbf315c3c3cc86fec36985f35baa78} 
auto Parser\+::parse\+\_\+func\+\_\+args (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ std\+::optional$<$std\+::vector$<$Expr\+Ptr$>$$>$\hspace{0.3cm}{\ttfamily [private]}}



Parses function arguments. {\ttfamily func\+\_\+args = "{}("{}, \mbox{[}function\+\_\+arg\+\_\+list\mbox{]}, "{})"{}} {\ttfamily function\+\_\+arg\+\_\+list = expression, \{"{},"{}, expression\}} 

\begin{DoxyReturn}{Returns}
A vector of unique pointers to parsed function arguments. 
\end{DoxyReturn}
\Hypertarget{classParser_aa7419a9e21d529d9af2e3d9878ac9ef6}\index{Parser@{Parser}!parse\_func\_call\_or\_parens@{parse\_func\_call\_or\_parens}}
\index{parse\_func\_call\_or\_parens@{parse\_func\_call\_or\_parens}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_func\_call\_or\_parens()}{parse\_func\_call\_or\_parens()}}
{\footnotesize\ttfamily \label{classParser_aa7419a9e21d529d9af2e3d9878ac9ef6} 
auto Parser\+::parse\+\_\+func\+\_\+call\+\_\+or\+\_\+parens (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a function call or a parenthesized expression. {\ttfamily function\+\_\+call = function\+\_\+args, call\+\_\+op, bind\+\_\+front} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed expression. 
\end{DoxyReturn}
\Hypertarget{classParser_a10fa8f1fbd7cb37efdba9b9f1fec9bb2}\index{Parser@{Parser}!parse\_func\_def@{parse\_func\_def}}
\index{parse\_func\_def@{parse\_func\_def}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_func\_def()}{parse\_func\_def()}}
{\footnotesize\ttfamily \label{classParser_a10fa8f1fbd7cb37efdba9b9f1fec9bb2} 
auto Parser\+::parse\+\_\+func\+\_\+def (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Func\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a function definition. {\ttfamily function\+\_\+def = func\+\_\+signature, block} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed function. 
\end{DoxyReturn}
\Hypertarget{classParser_a24abe38441c2a2fccb60e20f074e841f}\index{Parser@{Parser}!parse\_func\_param@{parse\_func\_param}}
\index{parse\_func\_param@{parse\_func\_param}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_func\_param()}{parse\_func\_param()}}
{\footnotesize\ttfamily \label{classParser_a24abe38441c2a2fccb60e20f074e841f} 
auto Parser\+::parse\+\_\+func\+\_\+param (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Param\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a function parameter. {\ttfamily func\+\_\+param = type\+\_\+non\+\_\+void, identifier} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed function parameter. 
\end{DoxyReturn}
\Hypertarget{classParser_a617a11e0305450dfb73e517ae2afa86d}\index{Parser@{Parser}!parse\_func\_signature@{parse\_func\_signature}}
\index{parse\_func\_signature@{parse\_func\_signature}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_func\_signature()}{parse\_func\_signature()}}
{\footnotesize\ttfamily \label{classParser_a617a11e0305450dfb73e517ae2afa86d} 
auto Parser\+::parse\+\_\+func\+\_\+signature (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Func\+Sign\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a function signature. {\ttfamily func\+\_\+signature = type, identifier, \mbox{[}function\+\_\+sign\+\_\+op, function\+\_\+def\+\_\+params\mbox{]}} {\ttfamily func\+\_\+def\+\_\+params = type\+\_\+non\+\_\+void, identifier, \{"{},"{}, type\+\_\+non\+\_\+void, identifier\}} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed function signature. 
\end{DoxyReturn}
\Hypertarget{classParser_a2cf88fbf89845a671a251f44cee0bf6c}\index{Parser@{Parser}!parse\_func\_type@{parse\_func\_type}}
\index{parse\_func\_type@{parse\_func\_type}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_func\_type()}{parse\_func\_type()}}
{\footnotesize\ttfamily \label{classParser_a2cf88fbf89845a671a251f44cee0bf6c} 
auto Parser\+::parse\+\_\+func\+\_\+type (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Type\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a function type. {\ttfamily func\+\_\+type = "{}\mbox{[}"{}, type, function\+\_\+sign\+\_\+op, func\+\_\+type\+\_\+args} {\ttfamily func\+\_\+type\+\_\+args = type\+\_\+non\+\_\+void, \{"{},"{}, type\+\_\+non\+\_\+void\}} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed function type. 
\end{DoxyReturn}
\Hypertarget{classParser_a4080c65b8d03d5d84ae6575fb292869e}\index{Parser@{Parser}!parse\_identifier@{parse\_identifier}}
\index{parse\_identifier@{parse\_identifier}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_identifier()}{parse\_identifier()}}
{\footnotesize\ttfamily \label{classParser_a4080c65b8d03d5d84ae6575fb292869e} 
auto Parser\+::parse\+\_\+identifier (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses an identifier expression. 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed identifier expression. 
\end{DoxyReturn}
\Hypertarget{classParser_adf3894b98d5d7843533382effea83913}\index{Parser@{Parser}!parse\_or\_expression@{parse\_or\_expression}}
\index{parse\_or\_expression@{parse\_or\_expression}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_or\_expression()}{parse\_or\_expression()}}
{\footnotesize\ttfamily \label{classParser_adf3894b98d5d7843533382effea83913} 
auto Parser\+::parse\+\_\+or\+\_\+expression (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses an OR expression (logical OR). {\ttfamily or\+\_\+expression = and\+\_\+expression, \{logical\+\_\+or, and\+\_\+expression\}} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed OR expression. 
\end{DoxyReturn}
\Hypertarget{classParser_a35e82cd54a8118d86990f8ffc1aaa7d8}\index{Parser@{Parser}!parse\_ret\_statement@{parse\_ret\_statement}}
\index{parse\_ret\_statement@{parse\_ret\_statement}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_ret\_statement()}{parse\_ret\_statement()}}
{\footnotesize\ttfamily \label{classParser_a35e82cd54a8118d86990f8ffc1aaa7d8} 
auto Parser\+::parse\+\_\+ret\+\_\+statement (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Statement\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a return statement. \`{}ret\+\_\+statement = ret, expression, "{};"{}. 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed return statement. 
\end{DoxyReturn}
\Hypertarget{classParser_a4d40bc258bbc03c5068c22839a994aa3}\index{Parser@{Parser}!parse\_statement@{parse\_statement}}
\index{parse\_statement@{parse\_statement}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_statement()}{parse\_statement()}}
{\footnotesize\ttfamily \label{classParser_a4d40bc258bbc03c5068c22839a994aa3} 
auto Parser\+::parse\+\_\+statement (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Statement\+Ptr}



Parses a single statement. 

\begin{DoxyReturn}{Returns}
Smart pointer to parsed statement. 
\end{DoxyReturn}
\Hypertarget{classParser_af7b27a75d600ee5e546f80a3828f8221}\index{Parser@{Parser}!parse\_term@{parse\_term}}
\index{parse\_term@{parse\_term}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_term()}{parse\_term()}}
{\footnotesize\ttfamily \label{classParser_af7b27a75d600ee5e546f80a3828f8221} 
auto Parser\+::parse\+\_\+term (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a term (multiplication, division). {\ttfamily term = unary\+\_\+factor, \{mult\+\_\+div\+\_\+op, unary\+\_\+factor\}} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed term. 
\end{DoxyReturn}
\Hypertarget{classParser_ad79892ddd65155e0587a4d0da44c20d0}\index{Parser@{Parser}!parse\_type@{parse\_type}}
\index{parse\_type@{parse\_type}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_type()}{parse\_type()}}
{\footnotesize\ttfamily \label{classParser_ad79892ddd65155e0587a4d0da44c20d0} 
auto Parser\+::parse\+\_\+type (\begin{DoxyParamCaption}\item[{bool}]{allow\+\_\+void}{ = {\ttfamily false}}\end{DoxyParamCaption}) -\/$>$ Type\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a type expression (e.\+g., int, void). {\ttfamily type = type\+\_\+non\+\_\+void \texorpdfstring{$\vert$}{|} void} {\ttfamily type\+\_\+non\+\_\+void = var\+\_\+type \texorpdfstring{$\vert$}{|} func\+\_\+type} 


\begin{DoxyParams}{Parameters}
{\em allow\+\_\+void} & Whether to allow the void type. {\ttfamily true} by default. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A unique pointer to the parsed type expression. 
\end{DoxyReturn}
\Hypertarget{classParser_a64b01431ae2ca929d115d3e4c359aea5}\index{Parser@{Parser}!parse\_unary@{parse\_unary}}
\index{parse\_unary@{parse\_unary}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_unary()}{parse\_unary()}}
{\footnotesize\ttfamily \label{classParser_a64b01431ae2ca929d115d3e4c359aea5} 
auto Parser\+::parse\+\_\+unary (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Expr\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a unary expression (negation, logical NOT). 

{\ttfamily unary\+\_\+factor = \mbox{[}unary\+\_\+operator\mbox{]}, factor} \begin{DoxyReturn}{Returns}
A unique pointer to the parsed unary expression. 
\end{DoxyReturn}
\Hypertarget{classParser_aac1e782dcb39f2d695a8e4b4e1e7cd83}\index{Parser@{Parser}!parse\_var\_type@{parse\_var\_type}}
\index{parse\_var\_type@{parse\_var\_type}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_var\_type()}{parse\_var\_type()}}
{\footnotesize\ttfamily \label{classParser_aac1e782dcb39f2d695a8e4b4e1e7cd83} 
auto Parser\+::parse\+\_\+var\+\_\+type (\begin{DoxyParamCaption}\item[{bool}]{allow\+\_\+void}{}\end{DoxyParamCaption}) -\/$>$ Type\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a variable type. {\ttfamily var\+\_\+type\+\_\+mut = \mbox{[}mut\mbox{]} var\+\_\+type} {\ttfamily var\+\_\+type = int} {\ttfamily \texorpdfstring{$\vert$}{|} flt} {\ttfamily \texorpdfstring{$\vert$}{|} string} {\ttfamily \texorpdfstring{$\vert$}{|} bool} 


\begin{DoxyParams}{Parameters}
{\em allow\+\_\+void} & Whether to allow the void type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A unique pointer to the parsed variable type. 
\end{DoxyReturn}
\Hypertarget{classParser_a126a309ba0da0a1ae7c7ddc2e5b5ad3b}\index{Parser@{Parser}!parse\_while\_loop@{parse\_while\_loop}}
\index{parse\_while\_loop@{parse\_while\_loop}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_while\_loop()}{parse\_while\_loop()}}
{\footnotesize\ttfamily \label{classParser_a126a309ba0da0a1ae7c7ddc2e5b5ad3b} 
auto Parser\+::parse\+\_\+while\+\_\+loop (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) -\/$>$ Statement\+Ptr\hspace{0.3cm}{\ttfamily [private]}}



Parses a while loop statement. {\ttfamily while\+\_\+loop = while, condition, block} 

\begin{DoxyReturn}{Returns}
A unique pointer to the parsed while loop statement. 
\end{DoxyReturn}
\Hypertarget{classParser_ad9dcf6e6e1b65d727b5acb1b204ac05c}\index{Parser@{Parser}!was\_last\_token@{was\_last\_token}}
\index{was\_last\_token@{was\_last\_token}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{was\_last\_token()}{was\_last\_token()}}
{\footnotesize\ttfamily \label{classParser_ad9dcf6e6e1b65d727b5acb1b204ac05c} 
auto Parser\+::was\+\_\+last\+\_\+token (\begin{DoxyParamCaption}\item[{Token\+Type}]{type}{}\end{DoxyParamCaption}) -\/$>$ bool\hspace{0.3cm}{\ttfamily [private]}}



Checks if the last token was of the specified type. 


\begin{DoxyParams}{Parameters}
{\em type} & The token type to check. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if the last token matches the given type, false otherwise. 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
include/parser.\+h\item 
src/parser/parser.\+cpp\end{DoxyCompactItemize}
